import tkinter
import sys
import random
 
from collections import namedtuple

WIDTH=1200
HEIGHT=800
FPS = 1000
global key
Point = namedtuple("Point", ["x", "y"])
MASS = []
VAL  = []
ZN = []
OM = []
W = 18
H = W*2//3
def draw_field(canvas):
    global cell_width
    global cell_height
    cell_width = WIDTH // W
    cell_height = HEIGHT // H
    def draw_cell(point):
        canvas.create_rectangle(
            cell_width * point.x,
            cell_height * point.y,
            cell_width * (point.x + 1),
            cell_height * (point.y + 1))

    canvas.delete(*canvas.find_all())
    for i in range(W):
        for j in range(H):
            draw_cell(Point(i, j))

    canvas.create_rectangle(
            cell_width * 0,
            cell_height * H//2,
            cell_width * (0 + 1),
            cell_height * (H//2 + 1),
            fill= 'green')
    canvas.create_rectangle(
            cell_width * W-2,
            cell_height * H//2,
            cell_width * (W-1),
            cell_height * (H//2 + 1),
            fill= 'green')

for i in range(H):
    vs = []
    zn = []
    for j in range(W):
        vs.append(0)
        zn.append(0)
    VAL.append(vs)
    ZN.append(zn)

VAL[H//2][0] = 1
VAL[H//2][W-1] = 1

c = tkinter.Canvas(width=WIDTH, height=HEIGHT)
B = c
draw_field(c)

def choose1(event):
    getx = event.x
    gety = event.y
    cx = getx // cell_width
    cy = gety // cell_height 
    VAL[cy][cx] = 1
    c.create_rectangle(
            cell_width * cx,
            cell_height * cy,
            cell_width * (cx + 1),
            cell_height * (cy + 1),
            fill= 'green')

def choose2(event):
    getx = event.x
    gety = event.y
    cx = getx // cell_width
    cy = gety // cell_height 
    VAL[cy][cx] = 2
    c.create_rectangle(
            cell_width * cx,
            cell_height * cy,
            cell_width * (cx + 1),
            cell_height * (cy + 1),
            fill= 'red')
def ver(event):
    getx = event.x
    gety = event.y
    cx = getx // cell_width
    cy = gety // cell_height 

    print('print value of this element')
    r = int(input())
    B.create_text(cell_width * (cx+0.5) , cell_height * (cy+0.5),  font="Purisa",text=str(r))

    ZN[cy][cx] = r

    if VAL[cy][cx] == 1:
        if len(MASS) < r:
            k = []
            MASS.append(k)
        if len(OM) < r:
            s = []
            OM.append(s)
        if r == 1 and len(MASS[0]) == 0:
            MASS[0].append(0)
        if r == 1 and len(OM[0]) == 0:
            OM[0].append(0)

c.bind('<Button-1>', choose1)
c.bind('<Button-3>', choose2)
c.bind('<Button-2>', ver)

def key_press(event):
    if event.keysym == "space":
        for x in range(1,H-2):
           for y in range(1,W-2):
               if VAL[x][y] == 1:
                    lop = ZN[x][y]
                    if VAL[x][y+1] == 2:
                        po = ZN[x][y+2]
                        re = ZN[x][y+1]
                        MASS[lop-1].append(po)
                        OM[lop-1].append(re)
                    elif VAL[x][y-1] == 2:
                        po = ZN[x][y-2]
                        re = ZN[x][y-1]
                        MASS[lop-1].append(po)
                        OM[lop-1].append(re)
                    elif VAL[x-1][y] == 2:
                        po = ZN[x-2][y]
                        re = ZN[x-1][y]
                        MASS[lop-1].append(po)
                        OM[lop-1].append(re)
                    elif VAL[x+1][y] == 2:
                        po = ZN[x+2][y]
                        re = ZN[x+1][y]
                        print([po,re])
                        MASS[lop-1].append(po)
                        OM[lop-1].append(re)
        t = MASS[len(MASS)-1][0]
        tom = OM[len(MASS)-1][0]
        MASS[len(MASS)-1][0] = 0
        OM[len(MASS)-1][0] = 0
        MASS[len(MASS)-1].append(t)
        OM[len(MASS)-1].append(tom)

        mass = MASS[:]
        Om_value = OM[:]
        print(mass)
        print(Om_value) 
        poi = 1
        while poi == 1:      
            #Приведение последовательных резистров
            l = [0]*2
            for x in range(len(mass)-1): 
                if len(mass[x]) == 2 and (x != 0):
                    k = mass[x]
                    valuek = Om_value[x]
                    mass[x] = [0]
                    p = -1
                    for y in range(len(mass[k[0]-1])):
                        p += 1
                        if mass[k[0]-1][y] == x+1:
                            mass[k[0]-1][y] = k[1]
                            l[0] = p
                    p = -1
                    for y in range(len(mass[k[1]-1])):
                        p += 1
                        if mass[k[1]-1][y] == x+1:
                            mass[k[1]-1][y] = k[0]
                            l[1] = p
                    Om_value[k[0]-1][l[0]] = Om_value[x][0]+Om_value[x][1]
                    Om_value[k[1]-1][l[1]] = Om_value[x][0]+Om_value[x][1]

            #Приведение параллельных участков
            
            t = -1
            for x in mass: 
                t += 1
                if len(x)>2 or t == 0 or t == len(mass):
                    for y in range(1,len(mass)+1):
                        a = x.count(y)

                        if a>1:
                            zn = x.index(y)
                            per = 1/Om_value[t][zn]
                            
                            for o in range(zn+1,len(x)): 
                                if x[o] == y:
                                    per = per + 1/Om_value[t][o]
                                    x[o] = -100
                            Om_value[t][zn] = 1/per
                            while -100 in x:
                                a = x.index(-100) 
                                Om_value[t].pop(a)
                                x.remove(-100) 
            poi = 0  
            t4 = -1
            for x in mass:
                t4 += 1
                if (len(x)==2) and (t4 != 0) and (t4 != (len(mass)-1)):
                    poi = 1
        print(mass)
        print(Om_value) 
        # СЛАУ по вершинам

        mass2 = mass[:]   
        mass_index = []
        t = -1
        p = 0
        for x in mass:
            t += 1
            if len(x)>2 or t == 0 or t == len(mass)-1:
                index = []
                e = -1
                for y in x:
                    e += 1
                    if y > 0:
                        p += 1
                        index.append(p)
                        k = mass2[y-1].index(t+1)
                        mass2[y-1][k] = -1000000 + p
                    elif y != 0:
                        index.append(y+1000000)
                mass_index.append(index)
          
        uravn = []
        len_index = p+1
        t1 = -1
        for x in mass:
            rebr = [0] * len_index
            t1 += 1
            if t1 != (len(mass)-1):
                if t1 == 0 :
                    rebr[0] = 1
                if len(x) > 2 or t1 == 0:
                    p1 = -1
                    for y in x:         
                        if y != 0:
                            p1 += 1
                            if y > (t1+1):
                                zn = -1
                            if (t1+1) > y:
                                zn = 1
                            rebr[mass_index[t1][p1]] = zn
                    rebr.append(0)
                    uravn.append(rebr)

        #Obhod konturov

        kontur = []
        t2 = -1
        for x in mass:
            t2 += 1
            if (len(x)>2) and (t2 != 0) and (t2 != len(mass)-1):
                for y in x:
                    for z in mass[y-1]:
                        for a in mass[z-1]:
                            if a == t2+10:
                                way = [t2+1,y,z]
                                kontur.append(way)

        p = -1
        for x in kontur:
            p+=1
            if not(x[0] < x[1] < x[2]):
                kontur[p] = -400
        for x in range(kontur.count(-400)):
            kontur.remove(-400)

        for x in kontur:
            rebr = [0]*(len_index-1)
            rebr[mass_index[x[0]-1][x[1]-1]] = Om_value[x[0]-1][x[1]-1]
            rebr[mass_index[x[1]-1][x[2]-1]] = Om_value[x[1]-1][x[2]-1]
            rebr[mass_index[x[2]-1][x[0]-1]] = -Om_value[x[2]-1][x[0]-1]
            rebr.append(0)
            uravn.append[rebr]
        root = []

        def kontur1(mass,root,t):
            for x in mass[t]:
                if x != 0:
                    root.append(x) 
                    if x == len(mass):

                        return root
                    else:
                        kontur1(mass,root,x)

        a = kontur1(mass,root,0)
        rebr = [0]*(len_index)

        w = 1
        for x in range(len(a)):
            s = mass[w-1].index(a[x])
            op = Om_value[w-1][s]
            pl = 0
            if mass[w-1][0] == 0:
                pl = 1
            rebr[mass_index[w-1][s-1]] = op
            w = a[x]
        print('Введите значение напряжения источника тока в Вольтах')
        rebr.append(int(input()))
        uravn.append(rebr)

        #решение СЛАУ методом Гаусса
        for y in range(1,len(uravn)):
            x = y
            while uravn[x][y] == 0: 
                x += 1
            i = uravn[y]
            uravn[y] = uravn[x]
            uravn[x] = i
            for t in range(y+1,len(uravn)):
                k1 = uravn[y][y]
                k2 = uravn[t][y]
                for q in range(len_index+1):
                   uravn[t][q] = uravn[t][q] * (k1/k2) - uravn[y][q]

        Amper_value = [0]*len_index 
        print(Amper_value)
        for y in range(len(uravn)-1,-1,-1):
            Amper_value[y] = uravn[y][len_index]/uravn[y][y]
            for r in range(y-1, -1, -1):
                uravn[r][len_index] = uravn[r][len_index] - uravn[r][y] * Amper_value[y]
                uravn[r][y] = 0
        t = -1
        for x in mass:
            ui = 0
            t += 1
            if len(x)>2 or t == 0 or t == len(mass)-1:
                ui += 1
                e = -1
                p = -1
                for y in x:
                    p+=1
                    if y > 0:
                        e += 1
                        wer = Amper_value[mass_index[ui][e]]
                        print('Ток на ветви ',t+1,'-----',p+1,' = ', '{0:4.2f}'.format(wer),' Ампер'  ) 
c.bind("<Key>", key_press)

 
c.pack()
c.focus_set()
c.mainloop()
