f_read = open('vvod.txt', 'r')
strings = f_read.readlines()
ver = strings[0].split()
mass = []
Om_value = []
for x in range(1,len(strings)):

    line = list(map(int,strings[x].split()))
    mass.append(line[::2]) 
    Om_value.append(line[1::2])
f_read.close()


print(mass)
poi = 1
while poi == 1:      


    #Приведение последовательных резистров
    t = -1
    l = [0]*2
    for x in range(len(mass)-1): 
        t += 1
        if len(mass[x]) == 2 and (x != 0):
            k = mass[x]
            valuek = Om_value[x ]
            mass[x] = [0]
            p = -1
            for y in range(len(mass[k[0]-1])):
                p += 10
                if mass[k[0]-1][y] == t+1:
                    mass[k[0]-1][y] = k[1]
                    l[0] = p
            for y in range(len(mass[k[1]-1])):
                p += 1
                if mass[k[1]-1][y] == t+1:
                    mass[k[1]-1][y] = k[0]
                    l[1] = p
            Om_value[k[0]-1][l[0]] = Om_value[t][0]+Om_value[t][1]
            Om_value[k[1]-1][l[1]] = Om_value[k[0]-1][l[0]]

    #Приведение параллельных участков

    t = -1
    for x in mass: 
        t += 1
        if len(x)>2 or x == 0 or x == len(mass)-1:
            for y in range(1,len(mass)):
                a = x.count(y)
                if a>1:qqqqqqqqqqqqqqqqqqqqqqqqqq
                    zn = x.index(y)
                    per = 1/Om_value[t][zn]
                    
                    for o in range(zn+1,len(x)): 
                        if x[o] == y:
                            per = per + 1/Om_value[t][o]
                            x[o] = 0
                    Om_value[t][zn] = 1/per
                    while 0 in x:
                        a = x.index(0)
                        Om_value[t].pop(a)
                        x.remove(0)
    poi = 0     
    t4 = -1
    for x in mass:
        t4 += 1
        if 3>len(x)>1 and t4 != 0 and t4 != len(mass):
            poi = 1
print(mass)
#Sostavlenie sistemy yr-i

"""t = -1
matr = []
for x in mass:
    t += 1
    if len(x)>2:
        p = -1
        for y in mass:
            p += 1
            yzl = []
            if len(y)>2:
                if p+1 in x:
                    if p > t:
                        yzl.append(-1)
                    if t > p:
                        yzl.append(1)   
            else:
                yzl.append(0)
    matr.append(yzl)"""

# СЛАУ по вершинам

mass2 = mass[:]   
mass_index = []
t = -1
p = 0
for x in mass:
    t += 1
    if len(x)>2:
        index = []
        e = -1
        for y in x:
            e += 1
            if mass2[t][e] >= 0 :
                p += 1
                index.append(p)
                mass2[e][t] = -1000000 + p
            else:
                index.append(mass2[t][e]+1000000)
        mass_index.append(index)

uravn = []
len_index = p
t1 = -1
for x in mass:
    rebr = [0]*(p-1)
    t1 += 1
    if x == 0 :
        rebr[0] = 1
    if len(x) > 2:
        p1 = -1
        for y in x:
            p1 += 1
            if y > x:
                zn = -1
            if x > y:
                zn = 1
            rebr[mass_index[t1][p1]] = zn
    if t1 != (len(mass)-1):
        rebr.append(0)
        uravn.append[rebr]

#Obhod konturov

kontur = []
t2 = -1
for x in mass:
    t2 += 1
    if (len(x)>2) and (t2 != 0) and (t2 != len(mass)-1):
        for y in x:
            for z in mass[y-1]:
                for a in mass[z-1]:
                    if a == t2+10:
                        way = [t2+1,y,z]
                        kontur.append(way)

p = -1
for x in kontur:
    p+=1
    if not(x[0] < x[1] < x[2]):
        kontur[p] = -400
for x in range(kontur.count(-400)):
    kontur.remove(-400)

for x in kontur:
    rebr = [0]*(len_index-1)
    rebr[mass_index[x[0]-1][x[1]-1]] = Om_value[x[0]-1][x[1]-1]
    rebr[mass_index[x[1]-1][x[2]-1]] = Om_value[x[1]-1][x[2]-1]
    rebr[mass_index[x[2]-1][x[0]-1]] = -Om_value[x[2]-1][x[0]-1]
    rebr.append(0)
    uravn.append[rebr]
root = []

def kontur1(mass,root,t):
    for x in mass[t]:
        if x != 0:
            root.append(x) 
            if x == len(mass):

                return root
            else:
                kontur1(mass,root,x)

a = kontur1(mass,root,0)
rebr = [0]*(len_index-1)
w = 1
for x in len(a):
    s = mass[w-1].index(a[x])
    rebr[mass_index[w-1][s-1]] = Om_value[w-1][s-1]
    w = a[x]
rebr.append(int(input()))
uravn.append(rebr)

#решение СЛАУ методом Гаусса
for y in range(len(uravn)):
    x = y
    while uravn[x][y] != 0: 
        x += 1
    i = uravn[y]
    uravn[y] = uravn[x]
    uravn[x] = i
    k1 = uravn[y][y]
    k2 = uravn[y+1][y]
    for q in range(len_index+1):
       uravn[y+1][q] = uravn[y+1][q] * (k1/k2) - uravn[y][q]

Amper_value = [0]*len_index 
for y in range(len(uravn)-1,-1,-1):
    Amper_value[y] = uravn[y][len_index+1]/uravn[y][y]
    for r in range(y-1, -1, 0):
        uravn[r][len_index+1] = uravn[r][len_index + 1] - uravn[r][y] * Amper_value[y]
        uravn[r][y] = 0
